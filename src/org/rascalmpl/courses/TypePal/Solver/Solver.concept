# Solver

.Synopsis
A Solver tries to solve the constraints in a TModel; unsolved constraints produce error messages

.Description

The purpose of a Solver is to solve the constraints that have been gathered by the <<Collector>>
and to produce a TModel.
The functions provided by a Solver are summarized below:

image::Solver.png[800,600,align="center"]

Two dozen functions (some very similar to the ones provided for <<Collector>>) are available 
that fall into the following categories:

* _Lifecycle of Solver_: create a new Solver and use it to solve the constraints in a given TModel.
* _Types_: retrieve the type of a program fragment in various ways, if that type is available.
* _Fact, Calculate & Require_: establish facts and define calculators and requirements.
* _Inference_: create new type variables for type inference.
* _Reporting_: report errors, warnings and info messages.
* _Global Info_:  access global information such as the current <<TypePal Configuration>>, available type facts,
  and the global store (EXPLAIN). 

In identical style as used for <<Collector>>, `Solver` is a datatype with a single constructur and with a number of functions as fields,
For instance, given a  `Solver` named `s`, calling the `getType` function amounts to: `s.getType(argument-of-getType)`.
All Solver functions are prefixed with `/* Solver field */` to emphasize that they
are a field of the Solver datatype.


The result of the Solver is an enriched `TModel` that contains, amongst others, messages regarding violated requirements
or types that could not be computed.
It can also be used to generate other usefull information about the program such as a use-def relation and
the used vocabulary (used for name completion).

== Lifecycle of Solver

Once, an initial TModel has been created by a <<Collector>>, a Solver takes over to solve constraints
and produce a final TModel. A new Solver can be created by `newSolver` that comes in two flavours:

[source,rascal]
----
Solver newSolver(Tree pt, TModel tm)
Solver newSolver(map[str,Tree] namedTrees, TModel tm){
----
The former takes a parse tree and an initial TModel and is intended
to solve the constraints for a single parse tree.
The latter takes a map of named parse trees and an initial TModel and can handle the situation of multiple trees
with mutual dependencies.

Finally, `run` creates the final TModel by solving the constraints in the initial TModel:
[source,rascal]
----
/* Solver field */ TModel () run
----
 
 
A complete type checking scenario (for a given a parse tree `pt` of the program to be checked) is:
[source,rascal]
----
c = newCollector("my_model", pt);  // create Collector
collect(pt, c);                    // collect constraints
initial_model = c.run();           // create initial TModel
s = newSolver(pt, c);              // create Solver
final_model = s.run();             // solve constraints and produce final TModel
----

The final TModel contains valuable information such as

* messages (errors, warnings, info);
* type facts for subtrees of the given parse tree;
* use/def relations.

== Types

Type-related functions try to retrieve various forms of type information from parts of the source program.
When that information is available, it is returned as result.
When it is not available, the internal exception `TypeUnavailable()` is thrown which will abort the execution of the
current requirement or calculator which will then be tried later again.

=== getType
The workhorse of TypePal is the function `getType` that determines 
the type of a given source code fragment *in the current scope*:

[source,rascal]
----
/* Solver field */ AType(value src) getType
----
Here `src` may either be a `Tree` (i.e., a parse tree fragment) or a `loc` (the source location of a parse tree fragment).

=== getTypeInScope
The function `getTypeInScope` determines 
the type of a given source code fragment *in a given scope  and given roles*:
[source,rascal]
----
/* Solver field */ AType (Tree occ, loc scope, set[IdRole] idRoles) getTypeInScope
----

Here 

* `occ` is a parse tree fragment;
* `scope` is the desired scope;
* `idRoles` is a set of allowed identifier roles.

=== getTypeInScopeFromName
The function `getTypeInScopeFromName` determines the type of a given name that has been bound via given indentifier roles
in a given scope. 
It is typically used to map a name of a type to its actual type, e.g., 
mapping the name `POINT` as it occurs in a declaration to the actual record type of `POINT`.

[source,rascal]
----
/* Solver field */ AType (str name, loc scope, set[IdRole] idRoles) getTypeInScopeFromName
----
Here:

* `name` is the name of the desired element;
* `scope` is the desired scope;
* `idRoles` is a set of allowed identifier roles.

=== getTypeInType

The function `getTypeInType` is typically used to determine parts of a container type such as, e.g., 
the fields in a named record type or the methods in a named class type.
[source,rascal]
----
/* Solver field */ AType (AType containerType, Tree selector, set[IdRole] idRolesSel, loc scope) getTypeInType
----
Here:

* `containerType` is a given container type;
* `selector` is a parse tree fragment to select a part from the container type (e.g., a field or method name);
* `idRolesSel` is a set of allowed identifier roles for the selector (e.g., `fieldId()` or `methodId()`);
* `scope` is the desired scope.

=== getAllDefinedInType
The function `getAllDefinedInType` is typically used to determine *all* named types that are defined in a container type,
e.g., all fields in a record type or all methods in a class type.

[source,rascal]
----
/* Solver field */ rel[str id, AType atype] (AType containerType, loc scope, set[IdRole] idRoles) getAllDefinedInType
----

Here:
* `containerType` is a given container type;
* `scope` is the desired scope;
* `idRoles` is a set of allowed identifier roles for the selectoed types.

== Fact, Calculate & Require

=== Fact
The function `fact` registers known type information for a program fragment `src`:
[source,rascal]
----
/* Solver field */ void (value src, AType atype) fact
----
Here

* `src` may either be a `Tree` (i.e., a parse tree fragment) or a `loc` (the source location of a parse tree fragment).
* `atype` is the AType to be associated with `src`.

=== equal and requireEqual
The function `equal` determines whether `l` and `r` are equal, the result is a Boolean value.
The function `requireEqual` just returns when the outcome is true, otherwise a FailMessage is reported.

[source,rascal]
----
/* Solver field */ bool (value l, value r) equal
/* Solver field */ void (value l, value r, FailMessage fmsg) requireEqual
----
Here the arguments `l` and `r` are either:

* an `AType`, or
* a `Tree`.

In the latter case, the type of the tree is used provided that it exists. 
Otherwise a `TypeUnavailable()` exception is generated and the calculator or requirement 
in which the predicate occurs is re-evaluated at a later time.

NOTE: This argument typing convention is used by all predicates discussed below.

=== subtype and requireSubType
The function `subtype` determines whether `l` is a subtype of `r`.
Under the hood, the user-provided function `getSubType` is called, see <<TypePal Configuration>>.
The function `requireSubtype` just returns when the outcome is true, otherwise the FailMessage is reported.

[source,rascal]
----
/* Solver field */ bool (value l, value r) subtype
/* Solver field */ void (value l, value r, FailMessage fmsg) requireSubType
----

=== comparable and requireCompare
The function `comparable` determines whether `l` is comparable with `r`.
Under the hood, the user-provided function `getSubType` is called twice, see <<TypePal Configuration>>.
The function `requireComparable` just returns when the outcome is true, otherwise the FailMessage is generated.

[source,rascal]
----
/* Solver field */ bool (value l, value r) comparable
/* Solver field */ void (value l, value r, FailMessage fmsg) requireComparable
----

=== unify and requireUnify
The function `unify` determines whether `l` can be unified with `r`.
Under the hood, the user-provided functions `getSubType` and `getLub` are used, see <<TypePal Configuration>>.
The function `requireUnify just returns when the outcome is true, otherwise the FailMessage is reported.
The bindings that may result from unification are effectutated when the enclosing calculate or require succeeds.

[source,rascal]
----
/* Solver field */ bool (value l, value r) unify
/* Solver field */ void (value l, value r, FailMessage fmsg) requireUnify
----

=== requireTrue and requireFalse
The function `requireTrue` returns when its condition is true, otherwise the FailMessage is reported.
The function `requireFalse` returns when its condition is false, otherwise the FailMessage is reported.

[source,rascal]
----
/* Solver field */ void (bool b, FailMessage fmsg) requireTrue
/* Solver field */ void (bool b, FailMessage fmsg) requireFalse
----

=== lub
The function `lub` return the least upper bound of two types.
Under the hood, the user-provided function `getLub` is called, see <<TypePal Configuration>>.
[source,rascal]
----
/* Solver field */ AType (value l, value r) lub
----

== Inference
=== instantiate
=== isFullyInstantiated
== Reporting
[source,rascal]
----
/* Solver field */ bool(FailMessage fmsg) report
/* Solver field */ bool (list[FailMessage] fmsgs) reports
----

== Global Info
=== getConfig[
source,rascal]
----
/* Solver field */ TypePalConfig () getConfig
----
=== getFacts
[source,rascal]
----
/* Solver field */ map[loc, AType]() getFacts
----
=== getStore
[source,rascal]
----
/* Solver field */ map[str,value]() getStore
----